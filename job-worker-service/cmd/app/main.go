// cmd/app/main.go
package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"regexp"
	"syscall"
	"time"

	"github.com/redis/go-redis/v9"

	_ "job-worker-service/docs" // swagger docs (generated by swag)

	"job-worker-service/internal/repository/postgresql"
	"job-worker-service/internal/service"
	httptransport "job-worker-service/internal/transport/http"
)

// @title Job Worker Service
// @version 1.0
// @description Async Job Worker microservice (API + worker via Redis + PostgreSQL)
// @BasePath /
// @schemes http
func main() {
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	pgDSN := mustEnv("POSTGRES_DSN")
	redisAddr := mustEnv("REDIS_ADDR")

	queueKey := envOr("REDIS_QUEUE_KEY", "jobs:queue")
	processingKey := envOr("REDIS_PROCESSING_KEY", "jobs:processing")
	httpAddr := envOr("HTTP_ADDR", ":8080")

	log.Printf("[app] config http_addr=%s redis_addr=%s queue_key=%s processing_key=%s postgres_dsn=%s",
		httpAddr, redisAddr, queueKey, processingKey, redactDSN(pgDSN),
	)

	// Postgres
	pool, err := postgresql.NewPool(ctx, pgDSN)
	if err != nil {
		log.Fatalf("pg: %v", err)
	}
	defer pool.Close()

	// Redis
	rdb := redis.NewClient(&redis.Options{Addr: redisAddr})
	if err := rdb.Ping(ctx).Err(); err != nil {
		log.Fatalf("redis: %v", err)
	}

	// DI
	repo := postgresql.NewJobRepository(pool)
	baseQueueKey := envOr("REDIS_QUEUE_KEY", "jobs:queue")
	baseProcessingKey := envOr("REDIS_PROCESSING_KEY", "jobs:processing")
	processingMapKey := envOr("REDIS_PROCESSING_MAP_KEY", baseProcessingKey+":map")

	queue := service.NewRedisPriorityQueue(
		rdb,
		processingMapKey,
		service.Lane{QueueKey: baseQueueKey + ":low", ProcessingKey: baseProcessingKey + ":low"},
		service.Lane{QueueKey: baseQueueKey + ":normal", ProcessingKey: baseProcessingKey + ":normal"},
		service.Lane{QueueKey: baseQueueKey + ":high", ProcessingKey: baseProcessingKey + ":high"},
	)

	jobSvc := service.NewJobService(repo, queue)

	h := httptransport.NewHandler(jobSvc)
	router := httptransport.Routes(h)

	srv := &http.Server{
		Addr:              httpAddr,
		Handler:           router,
		ReadHeaderTimeout: 5 * time.Second,
	}

	// run server
	go func() {
		log.Printf("app listening on %s", httpAddr)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("http: %v", err)
		}
	}()

	<-ctx.Done()

	shutdownCtx, cancel := context.WithTimeout(context.Background(), 8*time.Second)
	defer cancel()

	_ = srv.Shutdown(shutdownCtx)
	log.Println("app stopped")
}

func mustEnv(key string) string {
	v := os.Getenv(key)
	if v == "" {
		log.Fatalf("missing env: %s", key)
	}
	return v
}

func envOr(key, def string) string {
	v := os.Getenv(key)
	if v == "" {
		return def
	}
	return v
}

func redactDSN(dsn string) string {
	// postgres://user:pass@host:5432/db?...
	// заменим пароль на **** если он есть
	// простая, но рабочая маска: user:pass@ -> user:****@
	// не ломает DSN без пароля
	re := regexp.MustCompile(`://([^:/?#]+):([^@/]+)@`)
	return re.ReplaceAllString(dsn, `://$1:****@`)
}
